<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Begriffel ‚Äì PRIM</title>

  <style>
    :root{
      --bg:#fff;
      --text:#111;
      --muted:#6b7280;
      --border:#e5e7eb;

      --green:#22c55e;
      --yellow:#eab308;
      --gray:#9ca3af;

      --radius:18px;
      --tile-radius:14px;
      --shadow: 0 20px 60px rgba(0,0,0,.12);
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
      overflow:hidden; /* no scroll */
    }

    .stage{
      height:100dvh;
      padding: clamp(10px, 2.2vh, 18px);
      display:grid;
      place-items:center;
    }

    .wrap{
      width:min(560px, 100%);
      display:grid;
      gap: clamp(8px, 1.6vh, 14px);
      justify-items:center;
      text-align:center;
    }

    h1{
      margin:0;
      font-size: clamp(18px, 2.6vh, 22px);
      letter-spacing:.2px;
      line-height:1.1;
    }
    p{
      margin:0;
      color:var(--muted);
      font-size: clamp(12px, 1.7vh, 14px);
      line-height:1.25;
    }

    /* ===== Board ===== */
    .board{
      width:100%;
      border:1px solid var(--border);
      border-radius:var(--radius);
      padding: clamp(10px, 2vh, 14px);
      display:grid;
      gap: clamp(6px, 1.4vh, 10px);
      background:#fff;
    }

    .row{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap: clamp(6px, 1.4vh, 10px);
    }

    /* Shake row */
    .row.shake{
      animation: shake 380ms ease;
    }
    @keyframes shake{
      0%, 100% { transform: translateX(0); }
      20% { transform: translateX(-10px); }
      40% { transform: translateX(10px); }
      60% { transform: translateX(-8px); }
      80% { transform: translateX(8px); }
    }

    /* Flip tiles */
    .tile{
      perspective: 900px;
      border-radius: var(--tile-radius);
      user-select:none;
    }

    .tileInner{
      width:100%;
      aspect-ratio:1/1;
      border:2px solid var(--border);
      border-radius: var(--tile-radius);
      display:grid;
      place-items:center;
      font-weight:900;
      font-size: clamp(18px, 5.6vh, 34px);
      letter-spacing:1px;
      text-transform:uppercase;
      background:#fff;
      transform-style: preserve-3d;
      transition: transform 520ms cubic-bezier(.2,.8,.2,1), border-color 140ms ease;
    }

    .tile.revealing .tileInner{ transform: rotateX(180deg); }

    /* Front/back faces to avoid mirrored text */
    .face{
      grid-area: 1 / 1;
      backface-visibility: hidden;
      width:100%;
      height:100%;
      display:grid;
      place-items:center;
      border-radius: var(--tile-radius);
    }
    .front{
      background:#fff;
      color:var(--text);
    }
    .back{
      transform: rotateX(180deg);
      color:#fff;
    }

    /* Colors apply to INNER + back face background */
    .tile.green .tileInner{ border-color: var(--green); }
    .tile.green .back{ background: var(--green); }

    .tile.yellow .tileInner{ border-color: var(--yellow); }
    .tile.yellow .back{ background: var(--yellow); color:#111; }

    .tile.gray .tileInner{ border-color: var(--gray); }
    .tile.gray .back{ background: var(--gray); }

    /* little pop when typing */
    .tile.pop .tileInner{ transform: scale(1.03); }

    /* ===== Controls + Keyboard ===== */
    .controls{
      width:100%;
      display:grid;
      gap: clamp(6px, 1.2vh, 10px);
    }

    .msg{
      min-height: 18px;
      font-weight:800;
      font-size: clamp(12px, 1.6vh, 14px);
      color:#111;
    }

    .footer{
      font-size: 12px;
      color: var(--muted);
    }

    /* On-screen keyboard */
    .kb{
      width:100%;
      display:grid;
      gap: 8px;
      user-select:none;
      -webkit-user-select:none;
      touch-action: manipulation;
    }
    .kbRow{
      display:grid;
      grid-template-columns: repeat(10, 1fr);
      gap: 6px;
    }
    .kbRow.second{ grid-template-columns: repeat(9, 1fr); padding: 0 10px; }
    .kbRow.third{
      grid-template-columns: 1.35fr repeat(7, 1fr) 1.35fr;
    }

    .key{
      border:1px solid var(--border);
      background:#f3f4f6;
      color:#111;
      border-radius: 12px;
      padding: 12px 0;
      font-weight: 900;
      font-size: 14px;
      text-align:center;
      cursor:pointer;
      transition: transform 90ms ease, opacity 120ms ease;
    }
    .key:active{ transform: scale(.98); }
    .key.wide{ padding: 12px 0; }

    /* key coloring */
    .key.green{ background: var(--green); border-color: var(--green); color:#fff; }
    .key.yellow{ background: var(--yellow); border-color: var(--yellow); color:#111; }
    .key.gray{ background: var(--gray); border-color: var(--gray); color:#fff; }

    /* prevent accidental zoom on iOS by ensuring minimum font-size on tap */
    .key, .msg, .footer { -webkit-text-size-adjust: 100%; }

    /* ===== MODAL ===== */
    .modalOverlay{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.35);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      z-index: 9999;
    }
    .modalOverlay.show{ display:flex; }

    .modal{
      width:min(520px, 100%);
      background:#fff;
      border-radius: 22px;
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
      padding: 18px;
      text-align:center;
      display:grid;
      gap: 10px;
    }
    .modal h2{
      margin:0;
      font-size: 20px;
      font-weight: 900;
    }
    .modal .sub{
      margin:0;
      color: var(--muted);
      font-weight: 700;
      font-size: 14px;
      line-height: 1.25;
    }
    .modal .word{
      font-size: 26px;
      font-weight: 1000;
      letter-spacing: 2px;
    }
    .modal .btnRow{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 4px;
    }
    .btnLight{
      background:#fff;
      color:#111;
      border:1px solid var(--border);
    }
    button.modalBtn{
      padding: 14px 16px;
      border-radius: 14px;
      font-weight: 900;
      font-size: 15px;
      cursor:pointer;
    }

    @media (max-height: 720px){
      .key{ padding: 10px 0; }
      .kb{ gap: 6px; }
      .kbRow{ gap: 5px; }
    }
  </style>
</head>

<body>
  <div class="stage">
    <main class="wrap">
      <h1>Begriffel</h1>
      <p>4 Buchstaben. 6 Versuche.</p>

      <section class="board" id="board" aria-label="Spielbrett"></section>

      <section class="controls">
        <div class="msg" id="msg" aria-live="polite"></div>
        <div class="footer" id="dictStatus">W√∂rterbuch wird geladen ‚Ä¶</div>

        <!-- On-screen keyboard -->
        <div class="kb" id="keyboard" aria-label="Tastatur">
          <div class="kbRow first">
            <div class="key" data-key="Q">Q</div>
            <div class="key" data-key="W">W</div>
            <div class="key" data-key="E">E</div>
            <div class="key" data-key="R">R</div>
            <div class="key" data-key="T">T</div>
            <div class="key" data-key="Z">Z</div>
            <div class="key" data-key="U">U</div>
            <div class="key" data-key="I">I</div>
            <div class="key" data-key="O">O</div>
            <div class="key" data-key="P">P</div>
          </div>

          <div class="kbRow second">
            <div class="key" data-key="A">A</div>
            <div class="key" data-key="S">S</div>
            <div class="key" data-key="D">D</div>
            <div class="key" data-key="F">F</div>
            <div class="key" data-key="G">G</div>
            <div class="key" data-key="H">H</div>
            <div class="key" data-key="J">J</div>
            <div class="key" data-key="K">K</div>
            <div class="key" data-key="L">L</div>
          </div>

          <div class="kbRow third">
            <div class="key wide" data-key="ENTER">Enter</div>
            <div class="key" data-key="Y">Y</div>
            <div class="key" data-key="X">X</div>
            <div class="key" data-key="C">C</div>
            <div class="key" data-key="V">V</div>
            <div class="key" data-key="B">B</div>
            <div class="key" data-key="N">N</div>
            <div class="key" data-key="M">M</div>
            <div class="key wide" data-key="BACKSPACE">‚å´</div>
          </div>
        </div>
      </section>
    </main>
  </div>

  <!-- Modal -->
  <div class="modalOverlay" id="modalOverlay" role="dialog" aria-modal="true" aria-label="Ergebnis">
    <div class="modal">
      <h2>Geschafft! üéâ</h2>
      <p class="sub">Happy Birthday ‚ù§Ô∏è</p>
      <div class="word" id="modalWord">PRIM</div>

      <div class="btnRow">
        <button class="modalBtn btnLight" id="playAgain">Nochmal</button>
        <button class="modalBtn" id="closeModal" style="background:#111;color:#fff;border:1px solid var(--border);">Schlie√üen</button>
      </div>
    </div>
  </div>

  <script>
    // ===== Config =====
    const ANSWER = "PRIM";
    const WORD_LEN = 4;
    const MAX_TRIES = 6;

    // Always allow insider word(s)
    const ALWAYS_ALLOWED = new Set([ANSWER]);

    // If you want shake even for "valid but wrong", set true:
    const SHAKE_ON_WRONG_GUESS = false;

    // ===== State =====
    let tryIndex = 0;
    let isOver = false;
    let isBusy = false; // prevent double-enter during flip

    let DICT = new Set();
    let dictReady = false;

    // Typed letters for current row (using onscreen keyboard)
    let current = "";

    // Track best color for each keyboard letter (green > yellow > gray)
    const keyState = new Map(); // letter -> "green"|"yellow"|"gray"

    // ===== DOM =====
    const boardEl = document.getElementById("board");
    const msgEl = document.getElementById("msg");
    const dictStatusEl = document.getElementById("dictStatus");
    const kbEl = document.getElementById("keyboard");

    const overlay = document.getElementById("modalOverlay");
    const playAgainBtn = document.getElementById("playAgain");
    const closeModalBtn = document.getElementById("closeModal");
    const modalWordEl = document.getElementById("modalWord");

    // ===== Build board (6 rows x 4 tiles) =====
    const rows = [];  // row elements
    const tiles = []; // tiles[r][c] => tile wrapper
    for (let r = 0; r < MAX_TRIES; r++) {
      const row = document.createElement("div");
      row.className = "row";
      rows.push(row);

      const rowTiles = [];
      for (let c = 0; c < WORD_LEN; c++) {
        const tile = document.createElement("div");
        tile.className = "tile";

        const inner = document.createElement("div");
        inner.className = "tileInner";

        const front = document.createElement("div");
        front.className = "face front";
        front.textContent = "";

        const back = document.createElement("div");
        back.className = "face back";
        back.textContent = "";

        inner.appendChild(front);
        inner.appendChild(back);
        tile.appendChild(inner);

        row.appendChild(tile);
        rowTiles.push(tile);
      }

      boardEl.appendChild(row);
      tiles.push(rowTiles);
    }

    // ===== Helpers =====
    const setMsg = (t) => { msgEl.textContent = t || ""; };

    const sanitize = (v) => (v || "")
      .toUpperCase()
      .replace(/[^A-Z√Ñ√ñ√ú]/g, "")
      .slice(0, WORD_LEN);

    function isValidWord(w) {
      if (ALWAYS_ALLOWED.has(w)) return true;
      return dictReady && DICT.has(w);
    }

    function evaluateGuess(guess, answer) {
      // Proper Wordle-like duplicate handling
      const result = Array(WORD_LEN).fill("gray");
      const answerArr = answer.split("");
      const guessArr = guess.split("");

      // greens
      for (let i = 0; i < WORD_LEN; i++) {
        if (guessArr[i] === answerArr[i]) {
          result[i] = "green";
          answerArr[i] = null;
          guessArr[i] = null;
        }
      }
      // yellows
      for (let i = 0; i < WORD_LEN; i++) {
        if (guessArr[i] == null) continue;
        const idx = answerArr.indexOf(guessArr[i]);
        if (idx !== -1) {
          result[i] = "yellow";
          answerArr[idx] = null;
        }
      }
      return result;
    }

    function setTileText(r, c, ch) {
      const tile = tiles[r][c];
      const front = tile.querySelector(".front");
      const back = tile.querySelector(".back");
      front.textContent = ch || "";
      back.textContent  = ch || "";
    }

    function clearTileClasses(tile) {
      tile.classList.remove("green","yellow","gray","revealing","pop");
    }

    function paintRowTyping() {
      // show current letters in current row
      for (let c = 0; c < WORD_LEN; c++) {
        const ch = current[c] || "";
        const tile = tiles[tryIndex][c];
        // do not overwrite revealed colors on past rows
        if (tile.classList.contains("green") || tile.classList.contains("yellow") || tile.classList.contains("gray")) continue;
        setTileText(tryIndex, c, ch);
      }
    }

    function shakeRow(r) {
      const row = rows[r];
      row.classList.remove("shake");
      // force reflow
      void row.offsetWidth;
      row.classList.add("shake");
    }

    function openModal() {
      modalWordEl.textContent = ANSWER;
      overlay.classList.add("show");
      document.body.style.overflow = "hidden";
    }

    function closeModal() {
      overlay.classList.remove("show");
      document.body.style.overflow = "hidden";
    }

    function endGame(win) {
      isOver = true;
      if (win) openModal();
      else setMsg(`Leider nein üòà Das Wort war: ${ANSWER}`);
    }

    function resetGame() {
      tryIndex = 0;
      isOver = false;
      isBusy = false;
      current = "";
      keyState.clear();
      setMsg("");
      updateKeyboardVisuals(true);

      // clear board
      for (let r = 0; r < MAX_TRIES; r++) {
        rows[r].classList.remove("shake");
        for (let c = 0; c < WORD_LEN; c++) {
          const tile = tiles[r][c];
          clearTileClasses(tile);
          setTileText(r, c, "");
        }
      }
    }

    // Keyboard coloring priority: green > yellow > gray
    function mergeKeyState(letter, color) {
      const prev = keyState.get(letter);
      const rank = (x) => x === "green" ? 3 : x === "yellow" ? 2 : x === "gray" ? 1 : 0;
      if (rank(color) > rank(prev)) keyState.set(letter, color);
    }

    function updateKeyboardVisuals(reset=false) {
      const keys = kbEl.querySelectorAll(".key");
      keys.forEach(k => {
        if (reset) k.classList.remove("green","yellow","gray");
        const key = k.getAttribute("data-key");
        if (!key || key.length !== 1) return;
        const state = keyState.get(key);
        k.classList.remove("green","yellow","gray");
        if (state) k.classList.add(state);
      });
    }

    async function revealRowWithFlip(r, guess, colors) {
      isBusy = true;

      // Apply flip per tile with delay; set color mid-flip (when it "turns")
      const perDelay = 120;
      const midFlip = 260; // roughly half of 520ms transition

      for (let c = 0; c < WORD_LEN; c++) {
        const tile = tiles[r][c];
        const letter = guess[c];

        // lock letter on both faces
        setTileText(r, c, letter);

        // schedule reveal
        const delay = c * perDelay;

        setTimeout(() => {
          // start flip
          tile.classList.add("revealing");

          // set color around mid flip
          setTimeout(() => {
            tile.classList.add(colors[c]);
            // update keyboard
            mergeKeyState(letter, colors[c]);
            updateKeyboardVisuals();
          }, midFlip);

          // end flip state (so repeated transforms don't stack)
          setTimeout(() => {
            tile.classList.remove("revealing");
          }, 520);
        }, delay);
      }

      // wait for all animations to finish
      const total = (WORD_LEN - 1) * perDelay + 520 + 40;
      await new Promise(res => setTimeout(res, total));

      isBusy = false;
    }

    // ===== Dictionary loading =====
    async function loadDictionary() {
      try {
        // change file name here if needed:
        const res = await fetch("words4.txt", { cache: "no-store" }); // or "words.txt"
        if (!res.ok) throw new Error("HTTP " + res.status);

        const text = await res.text();
        const lines = text.split(/\r?\n/);

        for (const line of lines) {
          const w = sanitize(line.trim());
          if (w.length === WORD_LEN) DICT.add(w);
        }

        dictReady = true;
        dictStatusEl.textContent = `W√∂rterbuch geladen (${DICT.size} W√∂rter).`;
      } catch (e) {
        dictReady = false;
        dictStatusEl.textContent = "W√∂rterbuch konnte nicht geladen werden (Datei fehlt?).";
        setMsg("Fehler: Wortliste nicht gefunden. Lege words4.txt neben index.html.");
      }
    }
    loadDictionary();

    // ===== Input handlers (physical keyboard) =====
    document.addEventListener("keydown", (e) => {
      if (overlay.classList.contains("show")) {
        if (e.key === "Escape") closeModal();
        return;
      }
      if (isOver || isBusy) return;

      const k = e.key;

      if (k === "Enter") { submit(); return; }
      if (k === "Backspace") { backspace(); return; }

      const letter = sanitize(k);
      if (letter.length === 1) addLetter(letter);
    });

    // ===== On-screen keyboard =====
    kbEl.addEventListener("click", (e) => {
      const btn = e.target.closest(".key");
      if (!btn) return;
      if (overlay.classList.contains("show")) return;
      if (isOver || isBusy) return;

      const key = btn.getAttribute("data-key");
      if (!key) return;

      if (key === "ENTER") submit();
      else if (key === "BACKSPACE") backspace();
      else if (key.length === 1) addLetter(key);
    });

    // ===== Letter editing =====
    function addLetter(ch) {
      if (current.length >= WORD_LEN) return;
      current += ch;
      // small pop effect on next tile
      const idx = current.length - 1;
      const tile = tiles[tryIndex][idx];
      tile.classList.add("pop");
      setTimeout(() => tile.classList.remove("pop"), 90);

      paintRowTyping();
    }

    function backspace() {
      if (current.length === 0) return;
      current = current.slice(0, -1);
      paintRowTyping();
      // clear last tile char visually
      const idx = current.length;
      setTileText(tryIndex, idx, "");
    }

    // ===== Submit guess =====
    async function submit() {
      if (isOver || isBusy) return;
      if (!dictReady) { setMsg("W√∂rterbuch l√§dt noch ‚Ä¶"); shakeRow(tryIndex); return; }

      const guess = current;

      if (guess.length !== WORD_LEN) {
        setMsg(`Bitte genau ${WORD_LEN} Buchstaben.`);
        shakeRow(tryIndex);
        return;
      }

      if (!isValidWord(guess)) {
        setMsg("Das ist kein g√ºltiges deutsches Wort.");
        shakeRow(tryIndex);
        return;
      }

      setMsg("");
      const colors = evaluateGuess(guess, ANSWER);

      // Flip reveal animation
      await revealRowWithFlip(tryIndex, guess, colors);

      if (guess === ANSWER) {
        endGame(true);
        return;
      } else if (SHAKE_ON_WRONG_GUESS) {
        shakeRow(tryIndex);
      }

      tryIndex++;
      current = "";

      if (tryIndex >= MAX_TRIES) {
        endGame(false);
      } else {
        // prepare next row visuals
        paintRowTyping();
      }
    }

    // ===== Modal controls =====
    closeModalBtn.addEventListener("click", closeModal);
    playAgainBtn.addEventListener("click", () => {
      closeModal();
      resetGame();
    });
    overlay.addEventListener("click", (e) => {
      if (e.target === overlay) closeModal();
    });

    // Init
    resetGame();
  </script>
</body>
</html>
